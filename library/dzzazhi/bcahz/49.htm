<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<style type="text/css">
<!--
        A:link {text-decoration: none; color: blue}
        A:visited {text-decoration: none; color: blue}
        A:active {text-decoration: red}
        A:hover {text-decoration: underline; color:red}
        P,td,li{font-family: 宋体; font-size: 9pt}
        h1{font-family: 宋体; font-size: 11pt}
-->
</style>
<title>《编程爱好者》电子杂志第49期</title>
</head>

<body bgcolor="ffffcc">
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" height="74"
bordercolorlight="#000000" bordercolordark="#FFFFFF">
  <tr>
    <td width="496" height="70"><p align="center"><strong><a name="top"><font size="5"
    face="楷体_GB2312" color="#008040">编</font><font color="#008000" size="5"
    face="楷体_GB2312"> </font><font size="5" face="楷体_GB2312" color="#FF00FF">程</font><font
    color="#008000" size="5" face="楷体_GB2312"> <font color="#0000A0">爱</font> <font
    color="#800080">好</font> </font><font size="5" face="楷体_GB2312" color="#FF0000">者</a><br>
    </font><font color="#FF8000">一份面向广大编程爱好者的免费电子杂志</font></strong></p>
    <p align="center"><strong>总第49期</strong>　2000/05/17 　星期三&nbsp;&nbsp; 
    本期发送数: 9500</p>
    <p align="center">【<a href="http://www.pfan.net" target="_blank">杂志首页</a>】　【<a
    href="mailto:yaoz@citiz.net">编辑信箱</a>】　【<a
    href="mailto:yaoz@citiz.net?subject=question">提问信箱</a>】　【<a
    href="49.htm#subscribe">杂志订退</a>】</td>
  </tr>
</table>
</div>

<h1><br>
<font color="#FF0000"><span style="background-color: rgb(0,255,255)">本期栏目内容</span></font></h1>

<p><a href="49.htm#ksy"><strong>刊首语</strong></a></p>

<p><a href="49.htm#wyzp"><strong>网友作品</strong></a>

<ul>
  <li>BCBClean</li>
  <li>消息机</li>
  <li>Net Tools 1.2.2000.0508</li>
  <li>KeyGhost 键盘幽灵&nbsp; V3.10</li>
</ul>

<p><a href="49.htm#jswz"><strong>技术文章</strong></a>

<ul>
  <li><a href="49.htm#1">如何在Visual Basic中实现异步执行程序</a></li>
  <li><a href="49.htm#2">用VC6.0实现超级链接</a></li>
  <li><a href="49.htm#3">用Visual C++编写电子邮件程序</a></li>
  <li><a href="49.htm#4">破解WINDOWS屏幕保护密码</a></li>
  <li><a href="49.htm#5">让密码轻松显示</a></li>
  <li><a href="49.htm#6">通过ASP处理表单</a></li>
</ul>

<p><a href="49.htm#xzzq"><strong>下载专区</strong></a>

<ul>
  <li>dbAssist 2000 5.4b</li>
  <li>Online Database 4.0</li>
  <li>SQLGo&nbsp; 0.94b</li>
  <li>WinHEX 9.38</li>
  <li>Help &amp; Manual 2.52</li>
</ul>

<p><a href="49.htm#ywbd"><strong>有问必答</strong></a></p>

<p><a href="49.htm#zzxx"><strong>杂志信息</strong></a></p>

<p>　</p>

<h1><font color="#ff0000"><span style="BACKGROUND-COLOR: rgb(0,255,255)"><a name="ksy">刊 
首 语</a></span></font></h1>
<div align="left">

<table border="1" borderColorDark="#ffffff" borderColorLight="#000000" cellPadding="0"
cellSpacing="0" height="158" width="500">
<TBODY>
  <tr>
    <td bgColor="#ffc993" height="125"> 
    &nbsp;&nbsp;&nbsp; 亲爱的朋友大家好，在暂别了一个月后本刊又重新与大家见面了。在之前的一个月里，首先是我的国际顶级域名站点因为流量过大而被关闭，然后又因为我最近比较忙而耽搁了杂志的正常发送，就这样一推再推转眼就过了一个月。心里实在是万分的抱歉，也请所有关心和支持我的朋友能够谅解。<br>
    &nbsp;&nbsp;&nbsp; 经过本人的努力，我原来的国际顶级域名网站已于5月14日母亲节之际全面恢复，网站的界面做了一些小的调整，今后尽量会每日更新。欢迎各位新老朋友能莅临指教。请记住本站的国际顶级域名： 
    <font face="Times New Roman"><strong><a href="http://www.pfan.net">http://www.pfan.net</a></strong></font><br>
    &nbsp;&nbsp;&nbsp; 另外考虑到在之前的一个月里少发了太多期杂志，为了能最大限度的弥补大家，我决定在近几周内采取一周两期的方式发送，直到将漏掉的杂志补齐为止。欢迎大家能继续支持本刊。</td>
  </tr>
  <tr>
    <td height="15"><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>

<h1><a name="wyzp"><font color="#FF0000"><span style="background-color: rgb(0,255,255)">网 
友 作 品</span></font></a></h1>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000" height="112">
  <tr>
    <td bgcolor="#FFC993" height="79">&nbsp;&nbsp;&nbsp; <font color="#800080">您自己开发过软件吗? 
    您有自己满意的作品吗? 您希望发布推广您的作品吗? 
    本刊竭诚为您提供宣传空间。有意的朋友请把您的作品介绍以及下载地址、您的网址、电子邮件及相关信息发往 
    </font><a href="mailto:yaoz@citiz.net?subject=发布作品">yaoz@citiz.net?subject=发布作品</a><font
    color="#800080">（具体可以参照下面）。本刊免费为您宣传三期。如果您暂时没有个人主页，您可以将您的作品发给我，本站将竭诚为您提供存放空间。如还有疑问可以与我联系。</font></td>
  </tr>
  <tr>
    <td height="12"><a href="http://sunstone.163.net/download/Keyghost.zip"></a><p><font
    color="#0000FF"><strong>BCBClean</strong></font> <br>
    软件大小: 170,496bytes<br>
    作者: minuteman<br>
    Email: <a href="mailto:minuteman@263.net">minuteman@263.net</a><br>
    下载地址： <a href="http://go.163.com/~minute/soft/bcbcln.exe">http://go.163.com/~minute/soft/bcbcln.exe</a><br>
    用于清除BCB编程以及编译过程产生的无用文件，可以自己定制需清除的文件扩展名。</p>
    <p><font color="#0000FF"><strong>消息机</strong></font><br>
    软件大小: 161,792bytes<br>
    作者: minuteman<br>
    Email: <a href="mailto:minuteman@263.net">minuteman@263.net</a><br>
    下载地址： <a href="http://go.163.com/~minute/soft/MsgV2.exe">http://go.163.com/~minute/soft/MsgV2.exe</a><br>
    基于UDP的消息发送程序，可以在IP网上有确定地址的PC间传递短消息。</p>
    <p><font color="#0000FF"><strong>Net Tools</strong></font><br>
    软件版本：1.2.2000.0508<br>
    运行环境：Win98/WinNT<br>
    软件大小：376k<br>
    软件作者：NowCan<br>
    E-Mail ： <a href="mailto:nowcan@126.com">nowcan@126.com</a><br>
    下载地址：<br>
    软件类型：Internet 辅助，免费软件。<br>
    软件简介：查看本机IP地址、网卡地址及Winsocket的信息，查看所有TCP连接信息（包括：本地地址、端口，远程地址、端口，状态），地址解析，Trace 
    route，以及IP、ICMP、UDP、TCP数据包的统计数据。注意：Win95/97须升级Winsock2才可运行。</p>
    <p><strong><font color="#0000FF">KeyGhost 键盘幽灵&nbsp; V3.10</font><br>
    </strong>作者: 孙红阳<br>
    软件大小: 286k<br>
    主页: <a href="http://sunhy.126.com">http://sunhy.126.com</a><br>
    Email: <a href="mailto:sunstone@263.net">sunstone@263.net</a><br>
    下载地址： <a href="http://sunstone.163.net/download/Keyghost.zip">http://sunstone.163.net/download/Keyghost.zip</a><br>
    软件说明: 本软件运行后可记录键盘（包括小 
    键盘）的动作，同时可以控制软件的延时运行时间、启动的热键和存储文件的路径，并随时可以查阅键盘记录。并可以通过Internet发送键盘记录文件。<br>
    新增功能:<br>
    1.解决了windowsNT/2000中,两次Shift+F12键不能弹出的问题.现在默认键改为Alt+F12.<br>
    2.解决了windowsNT/2000中,随windows启动的问题.<br>
    3.在&quot;浏览记录&quot;窗口中加入了[删除记录]按钮,更加方便.<br>
    4.密码输入窗口的标题改为&quot;用户登录&quot;,更加隐蔽!<br>
    5.定时记录中增加了提示标签.<br>
    6.更新了&quot;浏览记录&quot;窗口中的多行显示的方法,更加方便.双击鼠标取消多行显示.<br>
    7.读入和保存大文件时,鼠标变为漏斗状态.</p>
    <p>　</td>
  </tr>
  <tr>
    <td height="15"><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>

<h1><span style="background-color: rgb(0,255,255)"><font color="#FF0000"><a name="jswz">技 
术 文 章</a></font></span></h1>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000">
  <tr>
    <td bgcolor="#FFC993" align="center"><a name="1"><strong>如何在Visual Basic中实现异步执行程序</strong></a></td>
  </tr>
  <tr>
    <td>　<p>　 使用 Visual Basic 
    编写应用程序的开发人员一定都遇到过这样的情形：当你的应用程序要完成一个比较大的任务时，并且该任务是那种“独占式”的任务（比如：使用 
    Visual Basic 的函数 FileCopy 复制一个超过50兆字节的文件），如果不对程序作出特殊的处理，则用户将被迫面对一个象是被“挂起”的窗体，任凭你用鼠标怎样点击也没有任何反应，更糟糕的是当你从屏幕保护程序切换回该程序时会看到程序的窗体变成了一块“白布”，这更加给人一种“死机”的感觉（其实不仅是使用Visual 
    Basic会遇到这种问题，使用其他的开发工具同样会存在，但其各自提供了自己的解决方法，这里我们姑且只讨论Visual 
    Basic，至于其他的开发工具请参考它们的开发文档）。如何避免这种尴尬的界面出现呢？笔者在实践中发现了一种简单的办法，在这里介绍给大家，希望能对您有所帮助。 
    <br>
    <br>
    　 这种办法是利用 Visual Basic 提供的创建ActiveX 
    部件的功能设计一个专门完成“大任务”的ActiveX 部件。Visual Basic 从5.0版本开始在创建ActiveX部件方面显示出前所未有的优秀品质。这里对ActiveX部件作如下简单介绍，以期适合不同的读者。Visual 
    Basic所能设计的部件共有两种：一种是可视的部件；另一种是不可视的部件。可视的部件包括ActiveX控件和ActiveX文档，最常见的ActiveX控件比如现今各种高级开发工具（Inprise 
    Delphi，Sybase PowerBuider等）都提供的按纽（Command或Button）、标签（Label）等等，ActiveX控件和窗体一起构成了应用程序与用户交互的界面。ActiveX文档使用在Internet应用程序中。由于我们的问题不涉及到可视的部件，所以这里不再赘述。 
    <br>
    <br>
    　 不可视的部件又称为代码部件，包括Active DLL部件和ActiveX EXE部件两种。ActiveX部件的另一个名称是ActiveX服务器，之所以被称作服务器是由于ActiveX部件与使用它们的应用程序之间的关系可以被类比为服务器程序与客户端程序之间的关系：ActiveX部件封装了特定的功能或业务规则，应用程序不需要知道ActiveX部件是如何实现这些功能或业务规则的，只需要通过ActiveX部件提供的编程接口（API：Applacation 
    Programming Interface ，ActiveX部件的API是由部件或其类的一系列属性、方法和事件构成的）传递应用程序的要求（通过属性或方法的参数），然后从部件的事件或其类的事件获得执行结果。根据ActiveX部件（ActiveX服务器）的执行方式可以把ActiveX部件分为进程内部件和进程外部件，所谓进程内部件即部件和使用它们的应用程序执行时共享同一个进程；而进程外部件却执行在自己的进程中，也可以这样认为：进程外部件的执行不影响使用它们的应用程序！显然，这个特性正是本文开始面对的那个问题所需要的。在部件中只有ActiveX 
    EXE部件是进程外部件，因此利用这个特性我们可以创建一个ActiveX EXE部件来完成“大任务”，而应用程序窗体只显示一些任务的提示信息，直到A!<br>
    ctiveX EXE部件的类的事件提示任务结束为止。这样应用程序就避免了那种呆板的“白布”窗体的出现，而能够响应任何来自用户的操作或者当从那些遮盖住它的程序切换回来时自行刷新。给用户的感觉是程序是在“异步”执行的。（注：关于创建ActiveX部件的详细信息请参考《Visual 
    Basic联机手册》或MSDN文档） <br>
    <br>
    　 
    下面我们通过例子来看如何实现这一想法：在这个例子中我们假设应用程序窗体是一个一直显示当前时间的数字时钟，当你使其执行“大任务”直到任务的完成，这期间你会发现数字时钟窗体从来就没有被“挂起”过，仍然能够响应你的拖动操作和不停地显示时间。以下是实现这一程序和ActiveX 
    EXE部件的步骤及源代码（以Visual Basic 6.0中文企业版为例）： <br>
    <br>
    　 一、 创建ActiveX EXE部件（BigJobServer）： <br>
    <br>
    　 步骤一：打开Visual Basic 6.0（或Visual Basic 5.0）新建一个Visual Basic工程，工程类型选择ActiveX 
    EXE，在工程资源管理器中选中工程1，然后在属性窗口中将其名称改为 
    BigJobServer。 <br>
    <br>
    　 步骤二：为工程添加一个Timer控件的容器窗体（添加窗体通过菜单 
    工程 &gt;添加窗体 完成）。窗体名称改为 frmClock 
    ；在窗体上放置一个Timer控件（从工具箱中选择Timer控件），名称改为 
    timClock。 <br>
    <br>
    　 说明：添加该窗体的用意是提供一个执行任务的定时器（Timer控件） 
    <br>
    <br>
    　 步骤三：设计实现“大任务”的类 BigJob（注：代码部件是通过各种类实现应用程序交给它的任务的，关于类的创建请参考《手册》或MSDN文档）默认情况下当你新建ActiveX 
    EXE部件时Visual Basic为你添加了一个名为Class1的类（要增加类通过菜单 
    工程&gt;添加类模块 完成），从工程资源管理器中选中Class1，然后在属性窗口中设置如下属性： 
    <br>
    <br>
    　 （名称）： BigJob <br>
    <br>
    　 Instancing： 5-MultiUse 
    （可被创建多个实例，详细情况参考《手册》）编写API：为类BigJob添加方法和事件（通过菜单工具 
    &gt;添加过程完成）部分代码及程序说明如下： <br>
    <br>
    Private frmTimeClock As frmClock '声明定时器容器窗体<br>
    Private WithEvents oTimer As Timer '声明定时器（包括其事件）<br>
    Public Event JobStart() '声明任务开始事件<br>
    Public Event JobEnd() '声明任务结束事件<br>
    <br>
    Private Sub Class_Initialize()<br>
    '---- 类初始化事件 ----<br>
    '在这里创建定时器窗体 frmTimeClock<br>
    '并引用定时器 oTimer<br>
    Set frmTimeClock = New frmClock<br>
    Load frmTimeClock<br>
    Set oTimer = frmTimeClock.timClock<br>
    oTimer.Enabled = False<br>
    End Sub<br>
    <br>
    Private Sub Class_Terminate()<br>
    '类终止事件，释放定时器并卸载定时器窗体<br>
    Set oTimer = Nothing<br>
    Unload frmTimeClock<br>
    End Sub<br>
    <br>
    　　　　Public Sub StartJob()<br>
    '方法 - 通知执行“大任务”<br>
    oTimer.Interval = 100<br>
    &nbsp;&nbsp;&nbsp; ‘经过0.1秒时间开始执行任务<br>
    oTimer.Enabled = True<br>
    End Sub<br>
    <br>
    Private Sub doBigJob()<br>
    '模拟的“大任务”是这个空耗时间的循环<br>
    '显然，这段代码在标准EXE程序中一定会造成“挂起”状态!<br>
    Dim lngTemp As Long<br>
    Dim lngSum As Long<br>
    <br>
    For lngTemp = 1 To 10000000<br>
    lngSum = lngSum + 1<br>
    Next<br>
    End Sub<br>
    <br>
    Private Sub oTimer_Timer()<br>
    '定时器周期到时开始执行任务<br>
    oTimer.Enabled = False<br>
    RaiseEvent JobStart '触发“开始执行”事件<br>
    doBigJob '执行“大任务”<br>
    RaiseEvent JobEnd '触发“任务结束”事件<br>
    End Sub<br>
    <br>
    <br>
    　 现在保存工程：选择菜单 文件&gt;保存工程，根据提示窗口选择合适的文件夹保存所有工程资源（工程文件，窗体文件，类文件）。 
    <br>
    <br>
    　 二、 使用并调试BigJobServer部件： <br>
    <br>
    　 步骤一：选择菜单 运行 &gt;全编译执行，可以看到除了Visual Basic进入运行工程 
    的状态之外看不到任何窗体出现，ActiveX EXE部件的调试比较特殊： 
    需要在另一个Visual Basic程序中进行。 <br>
    <br>
    　 步骤二：最小化Visual Basic，然后启动另一个Visual Basic的实例，新建一个标 
    准EXE工程。选择菜单 工程&gt;引用 ，在可引用的部件中我们可以找到 
    BigJobServer部件，选中该部件，按“确定”按纽返回。这样就建立了 
    应用程序和部件服务器间的联系。现在可以在这个工程中创建BigJob类 
    并使用其方法和事件了。 <br>
    <br>
    　 步骤三：在默认的窗体Form1上放置如下控件并设置其属性（方法同前）： 
    <br>
    <br>
    类型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 名称 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标题（Caption属性）<br>
    Label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lblTime 
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lblTime<br>
    Label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lblMessage&nbsp;&nbsp;&nbsp; lblMessage<br>
    Timer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timClock&nbsp;&nbsp;&nbsp; (无)<br>
    Command&nbsp;&nbsp;&nbsp; cmdStart&nbsp;&nbsp;&nbsp; 执行任务<br>
    步骤四：为该工程编写简单的代码：<br>
    Option Explicit<br>
    Dim WithEvents myJob As BigJob ‘声明BigJob对象（包括事件）<br>
    Private Sub Form_Load()<br>
    Set myJob = New BigJob ‘创建BigJob的实例<br>
    End Sub<br>
    <br>
    Private Sub Form_Unload(Cancel As Integer)<br>
    Set myJob = Nothing '释放对象<br>
    End Sub<br>
    <br>
    Private Sub cmdStart_Click()<br>
    myJob.StartJob '通知对象执行任务<br>
    End Sub<br>
    <br>
    Private Sub myJob_JobStart()<br>
    '在对象的“开始”事件中给用户一些提示<br>
    lblMessage.Caption = &quot;正在执行任务 ...&quot;<br>
    End Sub<br>
    <br>
    Private Sub myJob_JobEnd()<br>
    '在对象的“结束”事件中给用户一些提示<br>
    lblMessage.Caption = &quot;任务完成！&quot;<br>
    End Sub<br>
    <br>
    Private Sub timClock_Timer()<br>
    '“数字时钟”在不间断地显示当前时间<br>
    lblTime.Caption = Format(Now, &quot;HH:NN:SS&quot;)<br>
    End Sub<br>
    <br>
    <br>
    　 
    步骤五：保存并运行这个测试工程会看到如下结果：当你按下“执行任务”按纽 
    后从提示可以知道那个可怕的“大任务”已经开始执行，直到程序提示任 
    务结束，这期间无论是拖动窗体还是时间的显示均不会受到影响。由此可 
    见程序被“挂起”的尴尬局面得到了解决。 <br>
    <br>
    　 三、 补充说明： <br>
    <br>
    　 1、 上述程序在Visual Basic 6.0中文企业版上调试通过。 <br>
    <br>
    　 2、 要在你的程序中实现这种方法，可以改进ActiveX EXE部件。比如在类BigJob中把doBigJob过程替换为你的具体任务；或通过添加属性来传递适当的任务参数等等。 
    <br>
    <br>
    　 3、 关于ActiveX EXE部件的编译和发布问题，请参考《Visual Basic联机手册》或MSDN文档。</td>
  </tr>
  <tr>
    <td><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000">
  <tr>
    <td bgcolor="#FFC993"><p align="center"><strong><a name="2">用VC6.0实现超级链接</a><br>
    <br>
    湖北省襄樊市电信局计算机中心 张洪征</strong></td>
  </tr>
  <tr>
    <td>　<p>---- 很多windows软件的版权对话框中都设有超级链接，这些链接或提供公司网址，或提供电子邮件信箱，使操作者能够非常方便地与公司和作者联系，同时也为公司作了很好的宣传。如果能在自己写的软件中实现这个功能，定会使程序大增光彩。 
    <br>
    <br>
    ---- 实现这个功能要用到一个WINDOWS API函数ShellExecute，其原形为： <br>
    <br>
    HINSTANCE ShellExecute( <br>
    HWND hwnd, //窗口句柄<br>
    LPCTSTR lpOperation, //操作类型<br>
    LPCTSTR lpFile, //文件指针<br>
    LPCTSTR lpParameters, //文件可带的参数<br>
    LPCTSTR lpDirectory, //缺省目录<br>
    INT nShowCmd //显示方式<br>
    );&nbsp;&nbsp;&nbsp; <br>
    <br>
    ---- ShellExecute函数用于打开或执行一个文件，在调用此函数时只须指定要打开或执行的文件名，而不必管用什么程序去打开或执行文件，WINDOWS会自动根据要打开或执行的文件去判断该如何执行文件或用什么程序去打开文件。以下给出一个完整实例，具体实步骤： 
    <br>
    创建一个基于对话框的应用程序，命名为hyperlink； <br>
    <br>
    打开资源编辑器，在对话框上添加两个static text控件和两个button控件。 
    <br>
    ---- Static1和button1并列排放，Static1和button1并列排放。 <br>
    ---- 将static1的ID设为ID_STATIC1，caption设为：计算机世界日报：，button1的ID设为ID_BUTTON1，caption设为：http://www.computerworld.com.cn，并选中flat属性。将static2的ID设为：ID_STATIC2，caption设为为：给我写信：，button2的ID设为ID_BUTTON2，caption设为： 
    west_virginia@netease.com，并选中flat属性。 <br>
    <br>
    创建一个新光标，将其图标编辑成一个手的图像，其ID命名为ID_CURSOR1； 
    <br>
    <br>
    给ChyperlinkDlg类增加一个WM_SETCURSOR消息处理函数，其代码如下： <br>
    BOOL ChyperlinkDlg::OnSetCursor(CWnd* pWnd, <br>
    &nbsp;&nbsp;&nbsp; UINT nHitTest, UINT message) <br>
    {<br>
    &nbsp;&nbsp;&nbsp; CRect rcButton1,rcButton2;<br>
    &nbsp;&nbsp;&nbsp; CPoint ptCursor;<br>
    &nbsp;&nbsp;&nbsp; CWnd *pStatic1=GetDlgItem(IDC_BUTTON1);<br>
    &nbsp;&nbsp;&nbsp; CWnd *pStatic2=GetDlgItem(IDC_BUTTON2);<br>
    &nbsp;&nbsp;&nbsp; pStatic1-&gt;GetWindowRect (rcButton1);<br>
    &nbsp;&nbsp;&nbsp; pStatic2-&gt;GetWindowRect (rcButton2);<br>
    &nbsp;&nbsp;&nbsp; GetCursorPos(&amp;ptCursor);<br>
    &nbsp;&nbsp;&nbsp; if (rcButton1.PtInRect (ptCursor)||<br>
    &nbsp;&nbsp;&nbsp; rcButton2.PtInRect (ptCursor))<br>
    &nbsp;&nbsp;&nbsp; {<br>
    &nbsp;&nbsp;&nbsp; CWinApp *pApp=AfxGetApp();<br>
    &nbsp;&nbsp;&nbsp; HICON hIconBang=pApp-&gt;LoadCursor (IDC_CURSOR1);<br>
    &nbsp;&nbsp;&nbsp; SetCursor(hIconBang);<br>
    &nbsp;&nbsp;&nbsp; return TRUE;<br>
    &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; else<br>
    <br>
    return CDialog::OnSetCursor<br>
    (pWnd, nHitTest, message);<br>
    }<br>
    其作用是当鼠标位于button1和button2控件上时，<br>
    将其形状设为手形。<br>
    <br>
    5、 给IDC_BUTTON1增加BN_CLICKD消息处理函数，代码如下：<br>
    void ChyperlinkDlg::OnButton1() <br>
    {<br>
    &nbsp;&nbsp;&nbsp; // TODO: Add your control notification handler<br>
    code here<br>
    &nbsp;&nbsp;&nbsp; ShellExecute(m_hWnd,NULL, <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;http://www.computerworld.com.cn&quot;,<br>
    NULL,NULL,SW_SHOWMAXIMIZED);<br>
    }<br>
    <br>
    6、 给IDC_BUTTON2增加BN_CLICKD消息处理函数，代码如下：<br>
    void ChyperlinkDlg::OnButton2() <br>
    {<br>
    // TODO: Add your control notification<br>
    handler code here<br>
    ShellExecute(m_hWnd,NULL,<br>
    &quot;mailto:west_virginia@netease.com&quot;,<br>
    NULL,NULL,SW_SHOWMAXIMIZED);<br>
    }<br>
    <br>
    ---- 
    运行此程序，在对话框上显示计算机世界日报的首页链接和作者的电子邮件地址，在其上点鼠标左键后将自动进入计算机日报首页或启动邮件收发程序给作者写信，效果很理想。读者可在此基础上进一步完善，使其更专业化，也可将其写成类，用起来更方便。 
    <br>
    ---- ShellExecute是一功能很强大的函数，本文只使用了它的一种用法，更详细全面的用法可参考Visual 
    studio 6.0中所带的MSDN library 。 </td>
  </tr>
  <tr>
    <td><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000">
  <tr>
    <td bgcolor="#FFC993" align="center"><strong><a name="3">用Visual C++编写电子邮件程序</a><br>
    <br>
    南京市随园8-2号 王珂</strong></td>
  </tr>
  <tr>
    <td>　<p>一、概述<br>
    ---- 本文主要讲述如何使用Visual C++用MAPI编写E-mail程序。MAPI是包含在Windows之中的，因此不需要安装其他额外的部件。MAPI有以下三种形式：<br>
    SMAPI，Simple MAPI，简单的MAPI <br>
    <br>
    CMC，Common Messaging Calls，一般通讯调用<br>
    <br>
    完整的MAPI<br>
    ---- SMAPI和CMC都包含在完整的MAPI中，当用户想执行一些高级操作，比如编写自己的E-mail服务器的时候，必须使用完整的MAPI。本文主要阐述如何编写能够收发电子邮件的程序，因此使用SMAPI就足够了。 
    <br>
    二、编写电子邮件程序 <br>
    3-1 初始化MAPI <br>
    ---- 要使用MAPI，必须首先对它进行初始化。初始化包括以下三个步骤： 
    <br>
    <br>
    装载MAPI32.DLL动态链接库 <br>
    <br>
    找到想要调用的MAPI函数地址 <br>
    <br>
    登录到电子邮件对象 <br>
    3-1-1 装载MAPI32.DLL <br>
    ---- 要装载MAPI，用户必须程序运行时动态的装载一个动态链接库。LoadLibrary函数提供了此功能，它定位一个动态链接库，并返回HINSTANCE局柄（需要保存该句柄）。 
    <br>
    <br>
    LoadLibrary的语法如下：<br>
    LoadLibrary ( lpLibFileName );<br>
    其中lpLibFileName为LPCTSTR结构变量，<br>
    是所要调用的库的路径和名称。<br>
    <br>
    程序示例：<br>
    // 调用MAPI32.DLL并计算函数地址<br>
    HINSTANCE hInstMail;<br>
    hInstMail = ::LoadLibrary ( “MAPI32.DLL” );<br>
    if ( hInstMail == NULL )<br>
    {<br>
    &nbsp;&nbsp;&nbsp; // 错误处理<br>
    &nbsp;&nbsp;&nbsp; // 受篇幅限制,下面的错误处理部分省略<br>
    }<br>
    <br>
    3-1-2 确定函数地址 <br>
    ---- 由于MAPI32.DLL是被动态装载的，因此不知道所要调用的函数地址，也就不能一开始就调用它们，而要通过函数名获得函数的地址，并在动态链接库中查找每一个函数并核实。因此首先必须为这些函数声明指针 
    <br>
    <br>
    程序示例：<br>
    // 为MAPI32.DLL中的函数声明函数指针<br>
    ULONG (PASCAL *lpfnMAPISendMail) (LHANDLE lhSession, <br>
    ULONG ulUIParam, lpMapiMessage lpMessage, <br>
    FLAGS flFlags, ULONG ulReserved);<br>
    ULONG (PASCAL *lpfnMAPIResolveName) (LHANDLE lhSession, <br>
    ULONG ulUIParam, LPTSTR lpszName, <br>
    FLAGS ulFlags, ULONG ulReserved,<br>
    lpMapiRecipDesc FAR *lppRecip);<br>
    ULONG (FAR PASCAL *lpfnMAPILogon)(ULONG ulUIParam, <br>
    LPSTR lpszProfileName, LPSTR lpszPassword, <br>
    FLAGS flFlags, ULONG ulReserved, <br>
    LPLHANDLE lplhSession);<br>
    ULONG (FAR PASCAL *lpfnMAPILogoff)(LHANDLE lhSession, <br>
    ULONG ulUIParam, FLAGS flFlags,<br>
    ULONG ulReserved);<br>
    ULONG (FAR PASCAL *lpfnMAPIFreeBuffer)(LPVOID lpBuffer);<br>
    ULONG (FAR PASCAL *lpfnMAPIAddress)(LHANDLE lhSession,<br>
    ULONG ulUIParam, LPSTR lpszCaption,<br>
    ULONG nEditFields, LPSTR lpszLabels,<br>
    ULONG nRecips, lpMapiRecipDesc lpRecips,<br>
    FLAGS flFlags, ULONG ulReserved, <br>
    LPULONG lpnNewRecips, <br>
    lpMapiRecipDesc FAR *lppNewRecips);<br>
    ULONG (FAR PASCAL *lpfnMAPIFindNext)(LHANDLE lhSession,<br>
    ULONG ulUIParam, LPSTR lpszMessageType, <br>
    LPSTR lpszSeedMessageID, FLAGS flFlags,<br>
    ULONG ulReserved, LPSTR lpszMessageID);<br>
    ULONG (FAR PASCAL *lpfnMAPIReadMail)(LHANDLE lhSession, <br>
    ULONG ulUIParam, LPSTR lpszMessageID,<br>
    FLAGS flFlags, ULONG ulReserved, <br>
    lpMapiMessage FAR *lppMessage);<br>
    <br>
    ---- 为了决定每一个函数的地址，必须为每一个函数调用GetProcAddress。 
    <br>
    GetProcAddress的语法为：<br>
    &nbsp;&nbsp;&nbsp; GetProcAddress (hModule, lpProcName);<br>
    其中，hModule为HMODULE结构，是所调用DLL模块的句柄；<br>
    lpProcName为LPCSTR结构，是函数名称。<br>
    <br>
    程序示例：<br>
    // 找到MAPI32.DLL函数的地址，并将它们保存在函数指针变量里<br>
    (FARPROC&amp;) lpfnMAPISendMail = GetProcAddress(hInstMail,<br>
    “MAPISendMail”);<br>
    (FARPROC&amp;) lpfnMAPIResolveName = GetProcAddress(<br>
    hInstMail, “MAPIResolveName”);<br>
    (FARPROC&amp;) lpfnMAPILogon = GetProcAddress(hInstMail,<br>
    “MAPILogon”);<br>
    (FARPROC&amp;) lpfnMAPILogoff = GetProcAddress(hInstMail,<br>
    “MAPILogoff”);<br>
    (FARPROC&amp;) lpfnMAPIFreeBuffer = GetProcAddress(<br>
    hInstMail, “MAPIFreeBuffer”);<br>
    (FARPROC&amp;) lpfnMAPIAddress = GetProcAddress(hInstMail,<br>
    “MAPIAddress”);<br>
    (FARPROC&amp;) lpfnMAPIFindNext = GetProcAddress(hInstMail,<br>
    “MAPIFindNext”);<br>
    (FARPROC&amp;) lpfnMAPIReadMail = GetProcAddress(hInstMail,<br>
    “MAPIReadMail”);<br>
    <br>
    <br>
    3-1-3 登录到电子邮件对象 <br>
    ---- 用户必须在电子邮件系统中登录，才能实现MAPI的各种功能。MAPI提供了登录的三种选择： 
    <br>
    <br>
    登录到一个已经存在的对象。 <br>
    <br>
    登录到一个新对象，用编程的方法确定解释新信息。 <br>
    <br>
    使用对话框提示用户登录。 <br>
    ---- 
    我们通常选择登录到一个已经存在的电子邮件对象，因为网络合作用户通常会保持自己的电子邮件程序处于激活状态。登录通常使用MAPI提供的函数lpfnMAPILogon。 
    <br>
    lpfnMAPILogon的语法为：<br>
    lpfnMAPILogon (lpszProfileName, lpszPassword, flFlags, <br>
    ulReserved, lplhSession );<br>
    <br>
    ---- 其中，lpszProfileName指向一个256字符以内的登录名称，lpszPassword指向密码，它们均为LPTSTR结构。flFlags为FLAGS结构，其值详见表1。ulReserved必须为0。lplhSession为输出SMAPI的句柄。 
    <br>
    表1：lpfnMAPILogon函数中flFlags的值<br>
    值&nbsp;&nbsp;&nbsp; 意义<br>
    MAPI_FORCE_DOWNLOAD &nbsp;&nbsp;&nbsp;&nbsp; 
    在函数调用返回之前下载用户的所有邮件。<br>
    如果MAPI_FORCE_DOWNLOAD没有被设置，<br>
    那么信件能够在函数调用返回后在后台被下载。<br>
    MAPI_NEW_SESSION&nbsp;&nbsp;&nbsp;&nbsp; 建立一个新会话，<br>
    而不是获得环境的共享会话。如果MAPI_NEW_SESSION没有被设置，<br>
    MAPILogon使用现有的共享会话。<br>
    MAPI_LOGON_UI &nbsp;&nbsp;&nbsp;&nbsp; 
    显示一个登录对话框来提示用户输入登录信息。<br>
    例如Outlook检查用户电子邮件时便是如此。<br>
    MAPI_PASSWORD_UI&nbsp;&nbsp;&nbsp;&nbsp; MAPILogon只允许用户输入电子邮件的密码，<br>
    而不许改动账号。<br>
    <br>
    程序示例：<br>
    LHANDLE lhSession;<br>
    ULONG lResult = lpfnMAPILogon(0, NULL, NULL, 0, 0, <br>
    &amp;lhSession);<br>
    if (lResult != SUCCESS_SUCCESS)<br>
    //SUCCESS_SUCCESS在MAPI.H中被定义<br>
    {<br>
    &nbsp;&nbsp;&nbsp; // 错误处理<br>
    }<br>
    <br>
    <br>
    3-2 阅读电子邮件 <br>
    ---- MAPIFindNext和MAPIReadMail使用与阅读E-mail的两个基本函数。MAPIFindNext用于定位第一封或下一封电子邮件并返回标识号，MAPIReadMail返回以该标识号为基础的电子邮件的内容。另外，一个常用的函数是MAPIFreeBuffer，用于释放内存。 
    <br>
    <br>
    3-2-1 定位到第一封信 <br>
    <br>
    ---- 要找到第一封信，需要使用MAPIFindNext函数，其函数声明如下： <br>
    <br>
    ULONG FAR PASCAL MAPIFindNext(LHANDLE lhSession, <br>
    ULONG ulUIParam, LPTSTR lpszMessageType, <br>
    LPTSTR lpszSeedMessageID, FLAGS flFlags, <br>
    ULONG ulReserved, LPTSTR lpszMessageID )<br>
    <br>
    ---- 其中，lhSession为提交SMAPI的会话句柄 ；ulUIParam为父窗体的句柄；lpszMessageType指向一个字符串，用来鉴别邮件类型，并加以查找；lpszSeedMessageID为指向起始信息ID的指针，其值为0时，MAPIFindNext获得第一封电子邮件；flFlags的值见表2；ulReserved必须为0；lpszMessageID为输出值，它是指向信息ID地址的指针。 
    <br>
    ---- 表2：MAPIFindNext函数中flFlags的值 <br>
    <br>
    值&nbsp;&nbsp;&nbsp; 意义<br>
    MAPI_GUARANTEE_FIFO&nbsp;&nbsp;&nbsp; 按邮件发送的时间顺序接受电子邮件。<br>
    MAPI_LONG_MSGID&nbsp;&nbsp;&nbsp; 返回信件标识符可达512字符。<br>
    MAPI_UNREAD_ONLY&nbsp;&nbsp;&nbsp; 只列举没有阅读过的电子邮件。<br>
    <br>
    程序示例：<br>
    // 找到第一条没有阅读的电子邮件<br>
    char pMessageID [513];<br>
    ULONG lResult = lpfnMAPIFindNext(lhSession, NULL, NULL,<br>
    NULL, MAPI_LONG_MSGID | MAPI_UNREAD_ONLY,<br>
    0, pMessageID);<br>
    3-2-2 阅读信息<br>
    当信件ID被获取后，就可以调用MAPIReadMail<br>
    阅读实际的E-mail信息了。MAPIReadMail的函数声明如下：<br>
    ULONG FAR PASCAL MAPIReadMail(LHANDLE lhSession, <br>
    ULONG ulUIParam, LPTSTR lpszMessageID, <br>
    FLAGS flFlags, ULONG ulReserved,<br>
    lpMapiMessage FAR * lppMessage);<br>
    其中，lppMessage为指向MapiMessage的指针；<br>
    除flFlags外的其他参数与lpfnFindNext函数的同名参数意义相同，<br>
    flFlags参数的值见表3：<br>
    <br>
    表3：MAPIReadMail函数中flFlags的值：<br>
    值&nbsp;&nbsp;&nbsp; 意义<br>
    MAPI_BODY_AS_FILE&nbsp;&nbsp;&nbsp; 将邮件信息写到一个临时文件中，<br>
    并且将它作为第一个附件添加到附件列表中。<br>
    MAPI_ENVELOPE_ONLY&nbsp;&nbsp;&nbsp; 只读取邮件标题。<br>
    MAPI_PEEK&nbsp;&nbsp;&nbsp; 读完邮件之后不把它标记为“已读”。<br>
    MAPI_SUPPRESS_ATTACH&nbsp;&nbsp;&nbsp; MAPIReadMail函数不拷贝附件，<br>
    但是将邮件文本写入MapiMessage结构中。<br>
    <br>
    程序示例：<br>
    // 读取电子邮件<br>
    long nFlags = MAPI_SUPPRESS_ATTACH;<br>
    if (!bMarkAsRead)<br>
    &nbsp;&nbsp;&nbsp; nFlags = nFlags | MAPI_PEEK;<br>
    lResult = lpfnMAPIReadMail(lhSession, NULL, pMessageID,<br>
    nFlags, 0, &amp;pMessage);<br>
    if (lResult != SUCCESS_SUCCESS);<br>
    &nbsp;&nbsp;&nbsp; return false;<br>
    <br>
    如果调用成功，就可以访问MapiMessage结构了（使用pMessage）：<br>
    pMessage- &gt;ulReserved：0<br>
    pMessage- &gt;lpszSubject：邮件标题<br>
    pMessage- &gt;lpszNoteText：邮件信息<br>
    pMessage- &gt;lpszMessageType：邮件类型<br>
    pMessage- &gt;DateReceived：接收时间<br>
    pMessage- &gt;lpszConversationID：邮件所属的会话线程ID<br>
    pMessage- &gt;flFlags：其值见表4<br>
    <br>
    表4：MapiMessage结构中的flFlags<br>
    值&nbsp;&nbsp;&nbsp; 意义<br>
    MAPI_RECEIPT_REQUESTED&nbsp;&nbsp;&nbsp; 接收通知被申请。<br>
    客户端应用程序在发送消息时设置该项。<br>
    MAPI_SENT&nbsp;&nbsp;&nbsp; 邮件已被发送。<br>
    MAPI_UNREAD&nbsp;&nbsp;&nbsp; 邮件是“未读”状态。<br>
    <br>
    pMessage- &gt;lpOriginator：指向MapiRecipDesc结构，包含发件人信息。<br>
    pMessage- &gt;nRecipCount：信件者数目。<br>
    pMessage- &gt;lpRecips：指向MapiRecipDesc结构数组，包含接收者信息。<br>
    pMessage- &gt;nFileCount：附件数量。<br>
    pMessage- &gt;lpFiles：指向MapiFileDesc结构数组，<br>
    每一个结构包含一个文件附件。<br>
    <br>
    <br>
    3-2-3 释放内存 <br>
    ---- 在访问另一条信件以前应当释放内存，否则会出现内存泄漏。 <br>
    <br>
    程序示例：<br>
    <br>
    // 释放内存<br>
    lpfnMAPIFreeBuffer(pMessage);<br>
    3-2-4 定位到下一条信件<br>
    定位到下一条信件依然使用MAPIFindNext函数，<br>
    该函数声明及参数意义详见3-2-1节。下面示范如何定位到下一条信件。<br>
    <br>
    程序示例：<br>
    // 定位到下一条没有阅读的信件<br>
    ULONG lResult = lpfnMAPIFindNext(lhSession, NULL, NULL, <br>
    pMessageID, MAPI_LONG_MSGID|MAPI_UNREAD_ONLY, <br>
    0, pMessageID);<br>
    <br>
    <br>
    3-3 发送电子邮件 <br>
    ---- 发送电子邮件的一般步骤： <br>
    <br>
    ---- 1． 建立MapiMessage结构对象 <br>
    <br>
    ---- 2． 调用MAPIResolveName使发送者名称合法 <br>
    <br>
    ---- 3． 添加附件 <br>
    <br>
    ---- 4． 调用MAPISendMail发送电子邮件 <br>
    <br>
    ---- 5． 调用MAPIFreeBuffer释放内存 <br>
    <br>
    ---- 下面详细分别详细阐述。 <br>
    <br>
    3-3-1 建立MapiMessage结构对象 <br>
    <br>
    ---- 对于MapiMessage结构，3-2-2节已经做过介绍，下面一步步介绍如何设置其中的值： 
    <br>
    <br>
    ---- 1． 为MapiMessage对象分配内存： <br>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapiMessage message;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Memset(&amp;message, 0, sizeof(message));<br>
    <br>
    ---- 2． 将ulReserved设置为0： <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.ulReserved = 0;<br>
    <br>
    ---- 3． 设置信息类型指针lpszMessageType，可以为NULL： <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.lpszMessageType = NULL;<br>
    <br>
    ---- 4． 设置信件标题（lpszSubject）： <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char subject[512];<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(subject, sSubject);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.lpszSubject = subject;<br>
    <br>
    ---- 5． 设置信件内容： <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char text[5000];<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy(text, sMessage);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.lpszNoteText = text;<br>
    <br>
    ---- 6． 设置flFlags标识，详见3-2-2节中表4： <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.flFlags = MAPI_SENT;<br>
    <br>
    ---- 7． 用一个指向MapiRecipDesc结构的指针设置发送者信息（lpOriginator），或将其设置为NULL： 
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.lpOriginator = NULL;<br>
    <br>
    ---- 8． 设置接收者数目（nRecipCount），可以是1或更多： <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.nRecipCount = 1;<br>
    <br>
    ---- 9． 设置接收者信息（lpRecips），详见3-3-2节 <br>
    ---- 10． 设置附件数量（nFileCount） <br>
    <br>
    ---- 11． 设置附件信息，详见3-3-3节 <br>
    <br>
    b3-3-2 正确设置接收者信息 <br>
    <br>
    ---- 设置接收者信息时，应当使用MAPIResolveName函数来为MapiRecipDesc结构对象分配内存，并返回一个指针，该指针将被保存在MapiMessage结构的lpRecips中。MAPIResolveName的函数声明如下： 
    <br>
    <br>
    ULONG FAR PASCAL MAPIResolveName(LHANDLE lhSession, <br>
    ULONG ulUIParam, LPTSTR lpszName, <br>
    FLAGS flFlags, ULONG ulReserved, <br>
    lpMapiRecipDesc FAR * lppRecip )<br>
    <br>
    ---- 其中lppRecip即为前面提到的返回的指针。除flFlags外其余参数与前几个函数意义相同。flFlags的值详见表5。 
    <br>
    表5：MAPIResolveName中flFlags的值<br>
    值&nbsp;&nbsp;&nbsp; 意义<br>
    MAPI_AB_NOMODIFY&nbsp;&nbsp;&nbsp; 对话框为只读。如果MAPI_DIALOG被设置，<br>
    那么该项将被忽略。<br>
    MAPI_DIALOG&nbsp;&nbsp;&nbsp; 显示一个名称解决方案的对话框<br>
    MAPI_LOGON_UI &nbsp;&nbsp;&nbsp; 
    如果需要的话，将会显示仪个对话框让用户登录<br>
    MAPI_NEW_SESSION&nbsp;&nbsp;&nbsp; 新建一个会话<br>
    <br>
    程序示例：<br>
    char recipient[512];<br>
    strcpy(recipient, sTo);<br>
    lResult = lpfnMAPIResolveName(lhSession, 0, recipient,<br>
    0, 0, &amp;message.lpRecips);<br>
    <br>
    <br>
    3-3-3 添加附件 <br>
    ---- 
    下面的程序示例将演示如何在电子邮件中包含附件。只有一点需要说明：MapiFileDesc结构中flFlags的值，详见表6。 
    <br>
    <br>
    表6：MapiFileDesc结构中flFlags的值<br>
    值&nbsp;&nbsp;&nbsp; 意义<br>
    MAPI_OLE&nbsp;&nbsp;&nbsp; 附件是OLE对象。<br>
    MAPI_OLE_STATIC&nbsp;&nbsp;&nbsp; 附件是静态OLE对象。<br>
    0&nbsp;&nbsp;&nbsp; 附件将被视为数据文件<br>
    <br>
    程序示例：<br>
    // 设置附件信息<br>
    CString sPath, sFileName;<br>
    MapiFileDesc FileInfo;<br>
    char path[512];<br>
    char filename[512];<br>
    if (sAttachment == “”)<br>
    &nbsp;&nbsp;&nbsp; message.nFileCount = 0;<br>
    else<br>
    {<br>
    &nbsp;&nbsp;&nbsp; int nPos = sAttachment.ReverseFind(‘\\’);<br>
    &nbsp;&nbsp;&nbsp; if (nPos == -1)<br>
    &nbsp;&nbsp;&nbsp; {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sPath = sAttachment;<br>
    &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; else<br>
    &nbsp;&nbsp;&nbsp; {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sPath = sAttachment;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sFilename = sAttachment.Mid(nPos +1);<br>
    &nbsp;&nbsp;&nbsp; }<br>
    &nbsp;&nbsp;&nbsp; strcpy(path, sPath);<br>
    &nbsp;&nbsp;&nbsp; strcpy(filename, sFilename);<br>
    <br>
    &nbsp;&nbsp;&nbsp; message.nFileCount = 1;<br>
    &nbsp;&nbsp;&nbsp; FileInfo.ulReserved = 0;<br>
    <br>
    &nbsp;&nbsp;&nbsp; FileInfo.flFlags = 0;<br>
    <br>
    &nbsp;&nbsp;&nbsp; FileInfo.nPosition = sMessage.GetLength() –1;<br>
    &nbsp;&nbsp;&nbsp; FileInfo.lpszPathName = path;<br>
    &nbsp;&nbsp;&nbsp; FileInfo.lpszFileName = filename;<br>
    &nbsp;&nbsp;&nbsp; FileInfo.lpFileType = NULL;<br>
    &nbsp;&nbsp;&nbsp; message.lpFiles = &amp; m_FileInfo;<br>
    }<br>
    <br>
    <br>
    3-3-4 发送电子邮件 <br>
    ---- 使用MAPISendMail发送电子邮件，其声明如下： <br>
    <br>
    ULONG FAR PASCAL MAPISendMail (LHANDLE lhSession, <br>
    ULONG ulUIParam, lpMapiMessage lpMessage, <br>
    FLAGS flFlags, ULONG ulReserved )<br>
    <br>
    ---- 其中，flFlags的允许值为MAPI_DIALOG、MAPI_LOGON_UI和MAPI_NEW_SESSION，其意义与前几个函数中同名标识意义相同。 
    <br>
    程序示例：<br>
    <br>
    lResult = lpfnMAPISendMail(0, 0, &amp;m_message, 0, 0);<br>
    <br>
    <br>
    3-3-5 释放内存 <br>
    程序示例：<br>
    lpfnMAPIFreeBuffer(m_message.lpRecips);<br>
    <br>
    四、小结 <br>
    ---- 
    本文比较具体的介绍并演示了编写一个电子邮件程序的核心部分，如果读者要编写电子邮件程序，还需要进行的处理： 
    <br>
    ---- 1． 
    加上错误处理代码。受篇幅限制，本文的程序示例中只有两处为错误处理留空，比较它们的异同。电子邮件程序是非常容易出错的，因此除这两处外要在主要函数调用完成后都加上错误处理，或使用try 
    throw catch块处理例外。 <br>
    <br>
    ---- 2． 加上UI处理。 <br>
    <br>
    ---- 
    另外，本文所阐述的方法比较简单易行，事实上，有关电子邮件的程序远比这复杂得多，因此读者若需要编写一个功能强大的电子邮件程序，需要精通MAPI和SMTP/POP3等协议；如果读者要编写一个电子邮件服务器，那么不妨在精通MAPI和SMTP/POP3之后，阅读一些有关Exchange 
    Server的资料。</td>
  </tr>
  <tr>
    <td><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000">
  <tr>
    <td bgcolor="#FFC993" align="center"><strong><a name="4">破解WINDOWS屏幕保护密码</a> 
    <br>
    <br>
    成都 田茂均</strong></td>
  </tr>
  <tr>
    <td>　<p>　　一日，忽然发现用自己输入的密码不能上网，知道自己的健忘症又犯了，于是便坐下来苦苦回忆线索……只记得当初为方便记忆，上网与屏幕保护程序使用的是同一密码。于是找出大叠资料，意欲破解屏幕保护密码！<br>
    　　大家都知道，屏幕保护密码最多为16个字符。微软内置了16字节的密钥：48 
    EE 76 1D 67 69 A1 1B 7A 8C 47 F8 54 95 97 5F。Windows便用上述密钥加密你输入的密码。其加密过程为：首先将你输入的密码字符逐位转换为其16进制的ASCⅡ码值（小写字母先转为大写字母），再依次与对应密钥逐位进行异或运算，把所得16进制值的每一位当作字符，转换为其16进制ASCII码，并在其尾加上00作为结束标志，存入注册表HKEY_CURRENT_USER\Control 
    Panel\desktop下的二进制键ScreenSave_Data中。<br>
    　　懂得其加密原理后，便不难编程破解我的屏幕保护密码（即上网密码）了。本人用VB6.0编制了一读取注册表中ScrrenSave_Data值的函数GetBinaryValue(Entry 
    As String),读出其值为31 43 41 33 33 43 35 35 33 34 32 31 00,去掉其结束标志00，把余下字节转换为对应的ASCII字符，并把每两个字符组成一16进制数：1C 
    A3 3C 55 34 21，显然，密码为6位，将其与前6字节密钥逐一异或后便得出密码的ASCII码（16进制值）：54 
    4D 4A 48 53 48,对应的密码明文为TMJHSH，破解成功！用它拔号一试，呵，立刻传来Modem欢快的叫声。<br>
    　　附VB源程序：(程序中使用了窗体Form1，文本框Text1，命令按钮Command1)<br>
    　　1、窗体代码：<br>
    　　Option Explicit<br>
    　　Dim Cryptograph As String<br>
    　　Dim i As Integer<br>
    　　Dim j As Integer<br>
    　　Dim k As Integer<br>
    　　Dim CryptographStr(32) As Integer<br>
    　　Dim PWstr As String<br>
    　　Dim PassWord As String<br>
    　　Private Sub Command1_Click()<br>
    　　PWstr = “&quot;<br>
    　　PassWord = “&quot;<br>
    　　Text1.Text =“&quot;<br>
    　　Cryptograph = GetBinaryValue(“ScreenSave_Data&quot;)<br>
    　　k = Len(Cryptograph)<br>
    　　For j = 1 To k － 1<br>
    　　 For i = 32 To 126<br>
    　　 If Mid(Cryptograph, j, 1) = Chr(i) Then<br>
    　　 CryptographStr(j) = i<br>
    　　 End If<br>
    　　 Next i<br>
    　　Next j<br>
    　　i = (k － 1) / 2 '密码位数为(h－1)/2,根据位数选择解密过程。<br>
    　　Select Case i<br>
    　　Case 16<br>
    　　 GoTo 16<br>
    　　Case 15<br>
    　　 GoTo 15<br>
    　　Case 14<br>
    　　 GoTo 14<br>
    　　Case 13<br>
    　　 GoTo 13<br>
    　　Case 12<br>
    　　 GoTo 12<br>
    　　Case 11<br>
    　　 GoTo 11<br>
    　　Case 10<br>
    　　 GoTo 10<br>
    　　Case 9<br>
    　　 GoTo 9<br>
    　　Case 8<br>
    　　 GoTo 8<br>
    　　Case 7<br>
    　　 GoTo 7<br>
    　　Case 6<br>
    　　 GoTo 6<br>
    　　Case 5<br>
    　　 GoTo 5<br>
    　　Case 4<br>
    　　 GoTo 4<br>
    　　Case 3<br>
    　　 GoTo 3<br>
    　　Case 2<br>
    　　 GoTo 2<br>
    　　Case 1<br>
    　　 GoTo 1<br>
    　　Case Else<br>
    　　 End<br>
    　　End Select<br>
    　　16: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(31)) ＆ 
    Chr(CryptographStr(32))) Xor ＆H5F)<br>
    　　15: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(29)) ＆ 
    Chr(CryptographStr(30))) Xor ＆H97)<br>
    　　14: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(27)) ＆ 
    Chr(CryptographStr(28))) Xor ＆H95)<br>
    　　13: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(25)) ＆ 
    Chr(CryptographStr(26))) Xor ＆H54)<br>
    　　12: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(23)) ＆ 
    Chr(CryptographStr(24))) Xor ＆HF8)<br>
    　　11: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(21)) ＆ 
    Chr(CryptographStr(22))) Xor ＆H47)<br>
    　　10: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(19)) ＆ 
    Chr(CryptographStr(20))) Xor ＆H8C)<br>
    　　9: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(17)) ＆ 
    Chr(CryptographStr(18))) Xor ＆H7A)<br>
    　　8: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(15)) ＆ 
    Chr(CryptographStr(16))) Xor ＆H1B)<br>
    　　7: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(13)) ＆ 
    Chr(CryptographStr(14))) Xor ＆HA1)<br>
    　　6: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(11)) ＆ 
    Chr(CryptographStr(12))) Xor ＆H69)<br>
    　　5: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(9)) ＆ 
    Chr(CryptographStr(10))) Xor ＆H67)<br>
    　　4: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(7)) ＆ 
    Chr(CryptographStr(8))) Xor ＆H1D)<br>
    　　3: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(5)) ＆ 
    Chr(CryptographStr(6))) Xor ＆H76)<br>
    　　2: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(3)) ＆ 
    Chr(CryptographStr(4))) Xor ＆HEE)<br>
    　　1: PWstr = PWstr ＆ Chr((“＆H&quot; ＆ Chr(CryptographStr(1)) ＆ 
    Chr(CryptographStr(2))) Xor ＆H48)<br>
    　　For i = i To 1 Step －1 '所得PWstr的值为密码的倒序列，将其倒置便得出密码。<br>
    　　 PassWord = PassWord ＆ Mid(PWstr, i, 1)<br>
    　　Next i<br>
    　　Text1.Text = PassWord '在文本框内显示密码。<br>
    　　End Sub<br>
    　　2、模块代码：<br>
    　　Option Explicit<br>
    　　Const ERROR_SUCCESS = 0＆<br>
    　　Const ERROR_BADDB = 1009＆<br>
    　　Const ERROR_BADKEY = 1010＆<br>
    　　Const REG_EXPAND_SZ = 2＆<br>
    　　Const REG_BINARY = 3＆<br>
    　　Const KEY_QUERY_VALUE = ＆H1＆<br>
    　　Const KEY_ENUMERATE_SUB_KEYS = ＆H8＆<br>
    　　Const KEY_NOTIFY = ＆H10＆<br>
    　　Const READ_CONTROL = ＆H20000<br>
    　　Const STANDARD_RIGHTS_READ = READ_CONTROL<br>
    　　Const KEY_READ = STANDARD_RIGHTS_READ Or KEY_QUERY_VALUE Or KEY_ENUMERATE_SUB_KEYS 
    Or KEY_NOTIFY<br>
    　　Const HKEY_CURRENT_USER = ＆H80000001<br>
    　　Dim hKey As Long, MainKeyHandle As Long<br>
    　　Dim rtn As Long, lBuffer As Long, sBuffer As String, SubKey As String<br>
    　　Dim lBufferSize As Long<br>
    　　Declare Function RegOpenKeyEx Lib “advapi32.dll&quot; Alias “RegOpenKeyExA&quot; 
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As Long, ByVal samDesired 
    As Long, phkResult As Long) As Long<br>
    　　Declare Function RegCloseKey Lib “advapi32.dll&quot; (ByVal hKey As Long) As Long<br>
    　　Declare Function RegQueryValueEx Lib“advapi32.dll&quot; Alias“Reg 
    QueryValueExA&quot; (ByVal hKey As Long, ByVal lpValueName As String, ByVal lpReserved As 
    Long, lpType As Long, ByVal lpData As String, lpcbData As Long) As Long<br>
    　　Function GetBinaryValue(Entry As String)<br>
    　　MainKeyHandle = HKEY_CURRENT_USER<br>
    　　SubKey = “Control Panel\desktop\&quot;<br>
    　　rtn = RegOpenKeyEx(MainKeyHandle, SubKey, 0, KEY_READ, hKey)<br>
    　　 If rtn = ERROR_SUCCESS Then '如果HKEY_CURRENT_USER\Control Panel\desktop键被成功打开<br>
    　　 lBufferSize = 1<br>
    　　 rtn = RegQueryValueEx(hKey, Entry, 0, REG_BINARY, 0, lBufferSize) '读取ScreenSave_Data的值<br>
    　　 sBuffer = Space(lBufferSize)<br>
    　　 rtn = RegQueryValueEx(hKey, Entry, 0, REG_BINARY, sBuffer, lBufferSize)<br>
    　　 If rtn = ERROR_SUCCESS Then '如果读取ScreenSave_Data的值成功<br>
    　　 rtn = RegCloseKey(hKey)<br>
    　　 GetBinaryValue = sBuffer '函数返回ScreenSave_Data的值<br>
    　　 Else '如果读取ScreenSave_Data的值不成功<br>
    　　 Call ErrorMsg<br>
    　　 End<br>
    　　 End If<br>
    　　Else '如果HKEY_CURRENT_USER\Control Panel\desktop键不能打开<br>
    　　 Call ErrorMsg '调用ErrorMsg()过程<br>
    　　 End<br>
    　　 End If<br>
    　　End Function<br>
    　　Private Sub ErrorMsg() '显示错误信息过程<br>
    　　 Select Case rtn<br>
    　　 Case ERROR_BADDB<br>
    　　 MsgBox (“您的计算机注册表有错误!&quot;)<br>
    　　Case ERROR_BADKEY, REG_EXPAND_SZ<br>
    　　 MsgBox (“您的计算机未设屏保密码！&quot;)<br>
    　　Case Else<br>
    　　 MsgBox (“破解过程中遇到未知错误，错误号：&quot; ＆ Str＄(rtn))<br>
    　　 End Select<br>
    　　End Sub</td>
  </tr>
  <tr>
    <td><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000">
  <tr>
    <td bgcolor="#FFC993" align="center"><strong><a name="5">让密码轻松显示</a><br>
    <br>
    重庆 唐灿</strong></td>
  </tr>
  <tr>
    <td>　<p>　　 
    你梦想的密码显示程序是什么样子呢？不需要两个窗口之间的切换，不需要图标拖来拖去，只需要移动鼠标到密码框上，密码就会自动显示出来。真的有那么神奇吗？嗯哼，跟着我做吧。<br>
    　　首先，新建一个工程，然而建立一个公共模块，把以下代码贴入其中：<br>
    　　Declare Function SendMessage Lib “user32&quot; Alias “SendMessageA&quot; (ByVal 
    hwnd As Long, ByVal wMsg As Long, ByVal wParam As Long, lParam As Any) As Long<br>
    　　Declare Function IsWindow Lib “user32&quot; (ByVal hwnd As Long) As Long<br>
    　　Declare Function GetCursorPos Lib “user32&quot; (lpPoint As POINTAPI) As Long<br>
    　　Declare Function WindowFromPoint Lib“user32&quot; (ByVal xPoint As Long, ByVal 
    yPoint As Long) As Long<br>
    　　Declare Function InvalidateRect Lib “user32&quot; (ByVal hwnd As Long, lpRect As 
    Any, ByVal bErase As Long) As Long<br>
    　　Type RECT<br>
    　　 Left As Long<br>
    　　 Top As Long<br>
    　　 Right As Long<br>
    　　 Bottom As Long<br>
    　　End Type<br>
    　　Type POINTAPI<br>
    　　 x As Long<br>
    　　 y As Long<br>
    　　End Type<br>
    　　Public Const WM_PAINT = ＆HF<br>
    　　Public Const EM_SETPASSWORDCHAR = ＆HCC<br>
    　　Public Const WM_ERASEBKGND = ＆H14<br>
    　　你可以使用API文本查看器来助你一臂动，但一定要注意InvalidateRect函数中的lpRect参数类型应为Any,而不是Rect类型，否则……，呵呵，你试试就知道了。<br>
    　　接下来，在窗体上放置一个timer控件，把它的interval属性设为1000，也就是每秒一次。然后双击它，写入以下代码：<br>
    　　Private Sub Timer1_Timer()<br>
    　　Dim hwnd As Long<br>
    　　Dim WndIs As Long<br>
    　　Dim temp As Long<br>
    　　Dim CurrentP As POINTAPI<br>
    　　temp = GetCursorPos(CurrentP)<br>
    　　hwnd = WindowFromPoint(CurrentP.x, CurrentP.y)<br>
    　　WndIs = IsWindow(hwnd)<br>
    　　If WndIs &lt;&gt; 0 Then<br>
    　　 temp = SendMessage(hwnd, EM_SETPASSWORDCHAR, 0, 0)<br>
    　　 temp = InvalidateRect(0, 0, 1)<br>
    　　 End If<br>
    　　 End Sub<br>
    　　 OK，运行它。可是，这窗体上什么也没有，那么怎样才能显示密码？别急，这个窗体没有用了，你可以最小化它，然后打开密码程序，例如“拨号网络&quot;，把鼠标移动到它的“＊”上面，然后……，怎样？揉一揉眼睛，没错吧！<br>
    　　奥秘在哪儿呢？这个程序向你露出庞大的Windows消息系统的冰山一角，显示出一些鲜为人知的Windows系统的秘密。<br>
    　　众多的VB用户都知道，Windows程序是基于消息驱动的进程。每一个程序都调用了大量的外部模块，很多模块程序代码位于DLL库和ActiveX库中，各种模块通信的过程就是消息响应的过程。文本编辑控件可设置成PassWorChar属性，即成为密码框，它同样需要响应其它消息才能与其它模块进行通讯，比如，它响应——消息，你就可以利用GetWindowText函数取得它的内容（这就是上一个密码程序的原理呀）。同样，它响应EM_SETPASSWORDCHAR消息就可以把它由密码状态还原为初始状态，然后你必须再发送WM_PAINT消息来刷新它，才能完全显示出来。怎样，简单吧。抛砖引玉，你还可以发送其它消息来达到其它的效果。</td>
  </tr>
  <tr>
    <td><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000">
  <tr>
    <td bgcolor="#FFC993" align="center"><a name="6"><strong>通过ASP处理表单</strong></a></td>
  </tr>
  <tr>
    <td>　<p>　将输入的数据传送到服务器的方法，是使用HTML标记&lt;form&gt;...&lt;/form&gt;的表单，在浏览器端输入数据，点击&quot;submit&quot;按钮后，将表单中输入的数据传送到服务器加以处理。表单的语法如下：<br>
    　　&lt;form action=url method=get|post name=&quot;formname&quot; onreset=event1 
    onsubmit=event2<br>
    <br>
    target=window&gt;　　&lt;/form&gt;<br>
    <br>
    　　&middot;action:处理输入的数据的站点服务器程序的url地址。<br>
    <br>
    　　&middot;method:输入的数据传送到服务器的方式，如下：<br>
    <br>
    　　　　　get:将输入的数据加在action设定的url地址后面，传送到服务器<br>
    <br>
    　　　　　post:按照邮寄传输数据的方式，将输入的数据传送到服务器<br>
    <br>
    　　&middot;name:设定form的名称<br>
    <br>
    　　&middot;onreset:点击&quot;reset&quot;的按钮时执行所设定的子程序event1<br>
    <br>
    　　&middot;onsubmit:点击&quot;submit&quot;的按钮是执行的子程序event2<br>
    <br>
    　　&middot;target:指定输入数据结果所显示的窗口名称<br>
    <br>
    　　由表单的method可知，用户可以用如下的两种方法传送数据：<br>
    <br>
    　　1．get:用户端将数据加到url后，格式为&quot;?字段1=输入数据1&amp;字段2=输入数据2&amp;...&quot;,再将它送到服务器.譬如ACTION设为http://www.chinayancheng.net,字段Ｎumber的输入数据为001,字段Age的输入数据为23,则使用的get方法传给站点服务器的数据为http://www.chinayancheng.net?Number=001&amp;Age=23.<br>
    <br>
    　　2．post:用户端利用邮寄信息数据字段将数据传送到服务器。<br>
    <br>
    　　这种方法是使用Active Server Pages一个内置的&quot;对象&quot;(object)---request,依据get,post方法而异：<br>
    <br>
    get :使用&quot;输入数据=Request.querystring(&quot;字段名&quot;),将附加于url后的　数据取出，以取得此字段的输入数据。<br>
    <br>
    post:使用&quot;输入数据=Request.form(&quot;字段名&quot;),读取ＰＯＳＴ信息数据字段，以取得字段的输入数据。<br>
    <br>
    下面我们来举一个例子，这个例子的表单使用Get方法，在用户端使用浏览器，把数据输入表单以后，点击&quot;提交&quot;按钮，将显示处理的结果。假设ＷＥＢ服务器上ＡＳＰ文件名为form.asp，它的源程序代码如下：<br>
    <br>
    &lt;form action=&quot;exec.asp&quot; method=&quot;get&quot;&gt;<br>
    <br>
    姓名：&lt;input type=text name=&quot;aaa&quot; value=&quot;姓名&quot;&gt;<br>
    <br>
    &lt;br&gt;爱好：<br>
    <br>
    &lt;select name=&quot;bbb&quot;&gt;<br>
    <br>
    &lt;option&gt;足球<br>
    <br>
    &lt;option&gt;篮球<br>
    <br>
    &lt;option&gt;羽毛球<br>
    <br>
    &lt;option&gt;象棋<br>
    <br>
    &lt;option&gt;看书<br>
    <br>
    &lt;option&gt;玩游戏<br>
    <br>
    &lt;/select&gt;<br>
    <br>
    &lt;br&gt;<br>
    <br>
    &lt;input type=submit value=&quot;提交&quot;&gt;<br>
    <br>
    &lt;/form&gt;<br>
    <br>
    　　点击&quot;提交&quot;按钮后，执行WEB服务器的exec.asp脚本文件，exec.asp文件的源程序代码如下，由于表单(form)使用get方式，源程序代码使用&quot;输入数据=request.querystring(&quot;字段名&quot;),将附加于URL后的数据取出，以取得此段的输入数据：<br>
    <br>
    &lt;html&gt;&lt;body&gt;<br>
    <br>
    &lt;%=request.querystring(&quot;aaa&quot;)%&gt;你好，你的爱好是<br>
    <br>
    &lt;%=request.querystring(&quot;input2&quot;)%&gt;<br>
    <br>
    &lt;/body&gt;&lt;/html&gt;</td>
  </tr>
  <tr>
    <td><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>

<h1><a name="xzzq"><span style="background-color: rgb(0,255,255)"><font color="#FF0000">下 
载 专 区</font></span></a></h1>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000" height="472">
  <tr>
    <td bgcolor="#FFC993" height="40"><p align="left"><font color="#800080">我主页更新加入大量的编程工具，以下只是其中的5个。如果想要更多的编程工具、程序源码和控件的话，请来我的主页看看吧。</font><a
    href="http://www.pfan.net">http://www.pfan.net</a></td>
  </tr>
  <tr>
    <td height="414"><strong><a href="http://www.cybercrow.net.au/s_burak/home/dba_setup.exe">dbAssist 
    2000 5.4b</a> &nbsp; （2223K&nbsp; 共享软件）<a
    href="http://www.cybercrow.net.au/s_burak">相关站点</a></strong><br>
    dbAssist 是一个管理标准 xBase DBF 
    数据库的工具，，您可以创建数据库结构、进行索引、导入、导出、拷贝、过滤、替换、编辑、打印等，支持 
    Foxpro、Clipper、dBASE IV 等数据库格式。<p><strong><a
    href="http://61.128.193.119/soft21/oldatab.exe">Online Database 4.0</a> &nbsp; （772KB&nbsp; 
    免费软件）</strong><br>
    一个自由的网上数据库CGI语言编辑工具，你可用它创建自己的网上地址簿，访客录，反馈表以及出售表等等。它还提供密码保护。</p>
    <p><strong><a href="http://61.128.193.119/soft21/sqlgo.exe">SQLGo&nbsp; 0.94b</a> &nbsp; 
    （2.24 MB&nbsp; 免费软件）</strong><br>
    它提供了一个强有力的Microsoft SQL服务器编程环境，包括一个界面友好的编辑器和 
    SQL 开发器。</p>
    <p><strong><a href="http://www.sf-soft.de/winhex.zip">WinHEX 9.38</a>&nbsp; （430KB 
    &nbsp; 共享软件）<a href="http://www.winhex.com/">相关站点</a></strong><br>
    老牌Hex 十六进制编辑器工具，文件小、速度快，可做 Hex 与 ASCII 
    码编辑修改，多文件搜寻取代功能，一般运算及逻辑运算，硬盘磁区编辑(支持FAT16、FAT32和NTFS)自动搜寻编辑，文件对比和分析等功能，新增了RAM编辑功能。</p>
    <p><strong><a href="http://www.ec-software.com/pgm/hman2x.zip">Help &amp; Manual 2.52</a> 
    &nbsp; （4.7MB&nbsp; 共享软件）<a href="http://www.ec-software.com/hmpage.htm">相关站点</a></strong><br>
    Help &amp; Manual是一个所见即所得的 HELP 文件制作工具。<br>
    Help &amp; Manual可以很容易的创建Windows 3.x及Windows 95下的帮助文件并支持HTML帮助文件格式。Help 
    &amp; Manual能让你容易的创建和管理帮助文件内容包括标题、图像、宏、OLE对象和链接。利用的同样的数据，您还可以创建普通的HTML页面和RTF文件。</p>
    <p>　</td>
  </tr>
  <tr>
    <td height="12"><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>

<h1><a name="ywbd"><span style="background-color: rgb(0,255,255)"><font color="#FF0000">有 
问 必 答</font></span></a></h1>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000" height="110">
  <tr>
    <td bgcolor="#FFC993" height="49"><font color="#800080">提问信箱: </font><a
    href="mailto:yaoz@citiz.net?subject=question">yaoz@citiz.net?subject=question</a><font
    color="#800080"><br>
    如果您有什么疑难问题，请发到上面的信箱里，我会及时把您的问题放在杂志上的，希望编程高手们能不吝赐教，也希望这个栏目能成为大家交流的场所。</font></td>
  </tr>
  <tr>
    <td height="43">194. 回答请mailto: <a href="mailto:yaoz@citiz.net?subject=194">yaoz@citiz.net?subject=194</a><br>
    各位大虾：<br>
    大家好！我现在正在学习用VB 5.0编程，但遇到许多问题，望各位大虾帮忙解决！<br>
    ① VB 5.0中如何格式输入日期/时间（像VFP中一样）？<br>
    ② VB 5.0中如何把MDI窗口的最大最小化按钮关闭？<br>
    ③ VB 5.0中如何在最小化时在任务栏右下角缩小成图标？<br>
    我的EMAIL: <a href="mailto:anilsoft@zg-public.sc.cninfo.net">anilsoft@zg-public.sc.cninfo.net</a><p>195. 
    回答请mailto: <a href="mailto:yaoz@citiz.net?subject=195">yaoz@citiz.net?subject=195</a><br>
    各位网友，请问在VC6.0下基于对话框的程序加入CRichEditCtrl控件后，为何对话框不能显示？请回复<a
    href="mailto:wangdx-801@263.net">wangdx-801@263.net</a></p>
    <p>196. 回答请mailto: <a href="mailto:yaoz@citiz.net?subject=196">yaoz@citiz.net?subject=196</a><br>
    我作了一个 SQL Server 的 Table，有 2 个字段 ：MENU_ID，MENU_EXEC。<br>
    用意是用户输入 MENU_ID，然后程序在 TABLE 
    里面查找到要运行的程序，自动执行。<br>
    请问可行吗 ？ 如何实现 ？ <a href="mailto:william_ng@21cn.com">william_ng@21cn.com</a></p>
    <p>197. 回答请mailto: <a href="mailto:yaoz@citiz.net?subject=197">yaoz@citiz.net?subject=197</a><br>
    我初学vc6,遇到这样的问题：当我新建好一个对话框，并运行之，为什么一按回车键，对话框就卸载了呢？（不管对话框中是否有其他控件）这样的话，我做好的程序岂不是一按回车就退出，没法用？救命！！！<a
    href="mailto:yshidong@163.net">yshidong@163.net</a></p>
    <p>198. 回答请mailto: <a href="mailto:yaoz@citiz.net?subject=198">yaoz@citiz.net?subject=198</a><br>
    我想问下，怎样在VB6的DATAGRID控件中加入COMBOX或LISTBOX控件，实现DATAGRID中单元格数据的输入问题？我的油箱为： 
    <a href="mailto:cn_petro@dg.cnpc.com.cn">cn_petro@dg.cnpc.com.cn</a></p>
    <p>199. 回答请mailto: <a href="mailto:yaoz@citiz.net?subject=199">yaoz@citiz.net?subject=199</a><br>
    请问如何把vb 的程序最小化到windows右下角的任务栏？ 在vc++中使用一个Shell_notify的函数。在vb中不知怎么用？ 
    <a href="mailto:wufengzhi@telekbird.com.cn">wufengzhi@telekbird.com.cn</a></p>
    <p>200. 回答请mailto: <a href="mailto:yaoz@citiz.net?subject=200">yaoz@citiz.net?subject=200</a><br>
    各位网友，我正在编一个基于图片的信息隐藏的系统，但我对各种图象文件的格式不是很清楚，例如PCX、JIF，哪位有这方面的信息请告诉我，我的地址 
    <a href="mailto:wang_xiao_yun@21cn.com">wang_xiao_yun@21cn.com</a></p>
    <p>　</td>
  </tr>
  <tr>
    <td height="12"><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p>　</p>

<h1><a name="zzxx"><span style="background-color: rgb(0,255,255)"><font color="#FF0000">杂 
志 信 息</font></span></a></h1>
<div align="left">

<table border="1" cellpadding="0" cellspacing="0" width="500" bordercolordark="#FFFFFF"
bordercolorlight="#000000">
  <tr>
    <td bgcolor="#FFC993"><a name="subscribe"><strong>《编程爱好者》订退方法</strong></a><p><strong>退订</strong>：请以UNSUBSCRIBE 
    pfan为标题回信到 <a href="mailto:unsubscribe@buzzcity.com">unsubscribe@buzzcity.com</a><br>
    <strong>订阅</strong>：请在下面的文本框内输入您订阅本刊的邮件地址，并按右面的订阅按钮即可。如果您觉得这份刊物还不错的话，欢迎把它推荐给您的朋友。</p>
    <form name="buzzform" action="http://my.czine.buzzcity.com/cgi-bin/addBuzz">
      <input type="hidden" name="bidhost" value="broker.czine.buzzcity.com"><input type="hidden"
      name="gid" value="pfan"><input type="hidden" name="PF" value="czine"><p><input
      type="checkbox" name="bid"
      value="bdf34278f45a6678f875a9596af27c88,编程爱好者:编程技术,Su|" checked><a
      href="http://czine.buzzcity.com/Top/pfan/pfan_programm/"><b>订阅《编程爱好者》</b></a><input
      name="userid" size="15" maxlength="32"><input type="submit" value="赶快订阅!"
      style="font-family: 宋体; font-size: 9pt; background-color: rgb(0,255,255)"></p>
    </form>
    </td>
  </tr>
  <tr>
    <td>　<p>本刊已加入【CHINA-EZL】中国电子杂志联盟<br>
    联盟主页地址 <a href="http://china-ezl.yeah.net">http://china-ezl.yeah.net</a><br>
    <br>
    ◆欢迎光临我的个人主页<br>
    <br>
    ●《编程爱好者》<br>
    <a href="http://www.pfan.net">http://www.pfan.net</a> &nbsp; 
    （国际顶级域名主力站点）<br>
    <a href="http://person.zj.cninfo.net/~yao">http://person.zj.cninfo.net/~yao</a>&nbsp; （169镜像站点）<br>
    本刊的同名主页，主要以收集各类编程工具控件和程序源代码为主。</p>
    <p>不知道您看了这期刊物有什么想法或者是意见，欢迎向我提出来。<br>
    本人感激不尽，我的联系方法如下:<br>
    E-mail： <a href="mailto:yaoz@citiz.net">yaoz@citiz.net</a><br>
    ICQ#： 43260473</td>
  </tr>
  <tr>
    <td><p align="right"><a href="49.htm#top">Top</a></td>
  </tr>
</table>
</div>

<p><img
src="http://www.pfan.net/cgi-sys/Count.sys?st=55000&amp;md=6&amp;dd=cd&amp;tr=T&amp;ft=0&amp;frgb=Black&amp;df=pfan.net241.dat"
align="absmiddle" width="1" height="1"><img
src="http://person.zj.cninfo.net/cgi-bin/Count.cgi?ft=6&amp;frgb=0;215;255&amp;dd=C&amp;df=yao.dat"
width="1" height="1"></p>
</body>
</html>
